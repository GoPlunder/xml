<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>

<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <info>
        <title>XML-Praktikum SS 2015</title>
        <author>
            <personname>Belinda Zahra</personname>
            <email>belindazahra@yahoo.de</email>
        </author>
        <author>
            <personname>Thea Heim</personname>
            <email>thea.heim@web.de</email>
        </author>
        <author>
            <personname>Youlia Goldberg</personname>
            <email>goldbery@in.tum.de</email>
        </author>
    </info>
    <chapter>
        <title>Einleitung</title>
        <sect1>
            <title>Beschreibung und Motivation von CalendarX</title>
            <para>CalendarX ist ein im Web-Browser dargestellter Kalender, der neben den normalen
                Kalenderfunktionen noch zusätzliche Kalenderfunktionen mit sich bringt. Diese können
                folgendermaßen beschrieben werden.</para>
            <para><emphasis role="bold">Untersützung zusätzlicher Event-Typen
                    (Superevents):</emphasis>CalendarX macht es möglich, Beziehungen zwischen Events
                abzubilden, die keinem einzelnen Wiederholungsmuster enstprechen. So können nicht
                nur sich wöchentlich oder monatlich wiederholende Events abgebildet werden, sondern
                auch sich nach einem ganz anderen Muster wiederholende Events. Z.B. kann eine
                Vorlesung, die wöchentlich Montags von 10 bis 12 Uhr und Mittwochs von 13 bis 15 Uhr
                stattfindet, in einem einzelnen Event repräsentiert werden.</para>
            <para><emphasis role="bold">Unterstützung verschiedener Wiederholungs-Muster (reccurence
                    patterns):</emphasis>CalendarX unterstützt die gewöhnlichen Wiederholungsmuster
                (täglich, wöchentlich, monatlich), aber auch die Kombination dieser
                Wiederholungsmuster untereinander, einschließlich Ausnahmen. Z.B. kann CalendarX den
                Fall repräsentieren, dass ein Event an jedem ersten Montag und jeden dritten
                Mittwoch im Monat stattfindet, mit Ausnahme der Semesterferien.</para>
            <para>Zusammenfassend kann man die Motivation für dieses Praktikum darin beschreiben,
                dass wir einen Kalender entwickeln, der gegenüber den herkömmlichen Kalendersystemen
                über erweiterte Funktionalitäten verfügt, und somit auch von uns in der Realität
                gerne eingesetzt würde.</para>
        </sect1>
        <sect1>
            <title>Ziel und Organisation des XML-Praktikums</title>
            <para>Ziel des Praktikums ist es, das System CalendarX zu implementieren und zu
                dokumentieren. </para>
            <para>Client-seitig soll CalendarX im Web-Browser dabei die Möglichkeit bieten,
                Datumsangaben zu machen sowie eine Kalendersicht (Tages-, Wochen- oder Monatssicht)
                auszuwählen und die zugehörigen Kalenderdaten als SVG-Graphik berechnen zu lassen
                und anzuzeigen. Zudem soll jedes Event in der Kalendersicht mit einem Link versehen
                werden, welcher die Event-Daten in ein editierbares Formular lädt. Die im
                Eventformular durchgeführten Änderungen, sollen nach Bestätigung in die Datenbasis
                übertragen werden, wobei das Datum eines Events nicht änderbar ist.</para>
            <para>Die Dokumentation der Projektes erfolgt in DocBook und soll für die Abgabe in das
                PDF-Format umgewandelt werden.</para>
            <para>Der Ablauf des Praktikums verlief in zwei Phasen. In der ersten Hälfte des
                Semesters wurden in 5 freiwilligen Terminen die Grundlagen von XML, XDM, XPath,
                XSLT, XQuery, eXist, XForms und Docbook vermittelt. Zu jedem Termin gab es jeweils
                ein Aufgabenblatt, das auf das Praktikum vorbereitete bzw. schon Teile der späteren
                Projektentwicklung enthielt. Neben den Vorträgen der Kursleitung waren auch die
                Präsentationen der einzelnen Gruppen über die Lösungen der Aufgabenblätter sehr
                hilfreich für die eigene CalendarX-Entwicklung. In der zweiten Hälfte des Semesters
                arbeitete jede Gruppe für sich am eigenen Projekt. Das Ergebnis wird am Ende des
                Semesters in einer Präsentation vorgestellt.</para>
        </sect1>
    </chapter>
    <chapter>
        <title>Das Kalender-System CalendarX</title>
    <sect1>
            <title>Die XRX-Architektur</title>            
         <para><figure><title>CalendarX Component Layer Structure</title>
                <mediaobject>
                   <imageobject>
                        <imagedata fileref="Images/Architecture.png" scale="80"/>
                    </imageobject>
                </mediaobject>
            </figure></para>
       </sect1>   
        <sect1>
            <title>XML Schema: Die Architektur von CalendarX</title>
            <para>Das konzeptuelle Schema für Kalender-Daten</para>
        </sect1>
        <sect1>
            <title>Umsetzung der Tages-, Wochen und Monatssicht</title>
            <sect2>
                <title>SVG zur Erstellung der Templates</title>
                <para>Die Templates der Tages-, Wochen und Monatssicht wurden mit Hilfe von scalable
                    Vector Graphics (SVG) erstellt und mit Hilfe der Tages-, Wochen- und
                    Monatsstylesheets aufgerufen. Im ersten Schritt erhält das Template einen Namen,
                    um es später eindeutig zuordnen zu können. Danach wird die SVG-Fläche mit den
                    einleitenden Höhen- und Breitenangaben definiert. Innerhalb der SVG-Tags wird
                    die entsprechende Graphik gezeichnet.</para>
                <para>Nachfolgend wird beispielhaft das Template "tagessicht" beschrieben. Dieses
                    enthält 25 horizontale Linien, innerhalb zweier Linien steht jeweils die volle
                    Stunde von 0:00 Uhr bis 23:00 Uhr. Zudem enthält das Template eine vertikale
                    Linie, um die Uhrzeiten von den Kalendereinträgen abzugrenzen. <programlisting language="XML"><![CDATA[   <!-- Schreibt jede volle Stunde auf eine horizontale Linie -->
    <xsl:template name="tagessicht">
        <svg width="1300" height="1000" xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink">
            <!-- Im defs-Container werden die Objekte definiert -->
            <defs>
                <!-- Linie horizontal-->
                <line x1="50" y1="50" x2="1150" y2="50" 
                stroke-width="2" stroke="grey" id="li"/>
                <!-- Linie vertikal-->
                <line x1="100" y1="50" x2="100" y2="800" 
                stroke-width="2" stroke="grey" id="li2"/>
            </defs>
            <!-- Zeichne die oben definierte Linie 25 mal mit Abstand 30 -->
            <use xlink:href="#li" y="30"/>
            <use xlink:href="#li" y="60"/>
            <use xlink:href="#li" y="90"/>
            <use xlink:href="#li" y="120"/>
            <use xlink:href="#li" y="150"/>
            ...        
            <!-- Schreibe bestimmte Uhrzeit auf jede Linie -->
            <text x="55" y="100">00:00</text>
            <text x="55" y="130">01:00</text>
            <text x="55" y="160">02:00</text>
            <text x="55" y="190">03:00</text>
            ...            
            <!-- Zeichne vertikale Linie neben die Uhrzeiten -->
            <use xlink:href="#li2"/>
        </svg>]]>                       
                    </programlisting>
                </para>

            </sect2>
            <sect2>
                <title>XSLT zur Generierung der Event-Elemente</title>
                <para>Um die Event-Elemente eines Tages, einer Woche oder eines Monats in das
                    entsprechende Template einzutragen wird die XSL Transformation (XSLT), eine
                    Programmiersprache zu Transformation von XML Dokumenten, angewendet. Im ersten
                    Schritt wird der Datei, welche die Beispielevents enthält (sampleEvents.xml) ein
                    Stylesheet zugeordnet, das diese Events absteigend nach Datum und Startzeitpunkt
                    sortiert (sampleEvents.xsl). Das Ergebnis ist eine XML-Datei mit den sortierten
                    Event-Elementen (events_sortiert.xml). Aus dieser Zwischendatei heraus werden
                    dann die entsprechenden Stylesheets, entweder für die Tages-, die Wochen-, oder
                    die Monatssicht aufgerufen (tagessicht.xsl, wochensicht.xls, monatssicht.xsl).
                    Im ersten Schritt haben wir diese Funktionalität nur für einfache Events
                    (Einzelevents, die sich nicht wiederholen) umgesetzt. Später soll dieselbe
                    Vorgehensweise auch für die Superevents genutzt werden, indem ein Superevent als
                    eine Reihe von Einzelevents gesehen wird und ebenfalls nach Datum und
                    Startzeitpunkt sortiert wird.</para>
                <para>Nachfolgender Programmcode zeigt beispielhaft, wie die Events aus der
                    sortierten Zwischendatei gefiltert und jeweils als Rechteck, dessen Höhe von der
                    Dauer des Events abhängt, in das oben beschriebene SVG-Template der Tagessicht
                    hineingezeichnet werden. <programlisting><![CDATA[<xsl:template match="/">
        <svg  height="200%" width="100%">
            <!-- Template "tagessicht" wird aufgerufen -->
            <xsl:call-template name="tagessicht"/>
            
            <!-- Globale Variablen -->
            <xsl:variable name="aktuellesDatum" as="xs:date"
                select="document('aktuellesDatum.xml')/datum"/>
                
            <!-- Schreibe das Datum des Tages in die obere Mitte 
            der Seite (festgelegt in aktuellesDatum.xml) -->
            <text x="600" y="25" text-anchor="middle" 
            font-size="20" fill="red">
                <xsl:value-of select="$aktuellesDatum"/>
            </text>
            
            <!-- Falls vorhanden, trage die Termine für den 
            Tag in das Template ein -->
            <xsl:for-each
                select="document('events_sortiert.xml')/events/
                event[datum = $aktuellesDatum]">
                <xsl:variable name="startRechteck" select="80 + 
                (startZeitInMin div 2)"/>
                <xsl:variable name="endeRechteck" select="80 + 
                (endZeitInMin div 2)"/>
                
                <!-- Zeichne ein Rechteck für die Zeitspanne, 
                in der ein Termin stattfindet -->
                <rect x="105" y="{$startRechteck}" width="1040"
                    height="{($endeRechteck)-$startRechteck}" 
                    fill="gainsboro"/>             
                <!-- Schreibe Startzeit, Endzeit und die 
                Beschreibung in das Rechteck -->
                <text x="115" y="{$startRechteck +15}">
                    <xsl:value-of select="startZeit"/> - 
                    <xsl:value-of select="endZeit"/> :
                        <xsl:value-of select="beschreibung"/>
                </text>
            </xsl:for-each>
        </svg>       
    </xsl:template>]]></programlisting>
                </para>
                <para> Das Ergebnis enthält nun das Datum des aktuellen Tages, das Template der
                    Tagessicht und die Rechtecke für die Events an dem betrachteten Tag. Folgendes
                    Bild zeigt die Tagessicht nach der XSL Transformation: <figure>
                        <title>Template Tagessicht</title>
                        <mediaobject>
                            <imageobject role="html">
                                <imagedata fileref="Images/tagessicht.png"/>
                            </imageobject>
                            <imageobject role="fo">
                                <imagedata scalefit="1" width="100%" contentdepth="100%"
                                    format="PDF" fileref="Images/tagessicht.png"/>
                            </imageobject>
                        </mediaobject>
                    </figure>
                </para>
            </sect2>
            <sect2>
                <title>Wiederverwendung der Templates</title>
                <para>Bei der Erstellung der Templates wurde darauf geachtet, dass sie nicht nur für
                    eine Sicht verwendet werden können, sondern auch für die Erstellung der anderen Sichten brauchbar sind.</para>
                <para>Mit Hilfe des Befehls <![CDATA[<xsl:include href="tagessicht.xsl"/>]]> wird
                    das Stylesheet der Tagessicht, dessen Template in der Wochensicht benötigt wird,
                    in diese mit eingebunden. Genauso wird in der Monatssicht das Stylesheet der
                    Tagessicht eingebunden. Mit Hilfe des Befehls
                    <![CDATA[ <xsl:call-template name="tagessicht"/>]]> können einzelne Templates
                    aufgerufen werden. </para>
            </sect2>
            <sect2>
                <title>Uhrzeit</title>
                <para>Die Uhrzeit wird durch xs:time dargestellt. Die voreingestellte Darstellung
                    eines xs:time ist Stunden:Minuten:Sekunden (hh:mm:ss). Dank der
                    Formatierungsfunktion format-time() in XSLT 2.0 kann man xs:time Werte verwenden
                    und dann das Format dieser ändern. Somit können wir die Sekunden in den Sichten
                    weglassen und erhalten stattdessen die Darstellung Stunden:Minuten
                    (hh:mm).</para>
            </sect2>
            <sect2>
                <title>Einbindung der FuncX Bibliothek</title>
                <para>Für die Manipulation von Datums- und Zeitangaben wird die XSLT-Bibliothek FuncX 
                    (<link xlink:href="http://www.xsltfunctions.com/"></link>) verwendet. Die Bibliothek wird v.a. dazu benötigt, um die
                    Wochen und Monate mit den richtigen Daten zu füllen. Mit Hilfe ihrer Funktionen können so
                    beispielsweise der erste Tag im Monat, die Anzahl der Tage eines Monats, die Nummer eines Tages im Jahr, u.v.m. bestimmt 
                    werden. </para>
            </sect2>
        </sect1>
        <sect1>
            <title>Benutzeroberfläche</title>
            <para>Beschreibung der unterstützen Seiten, den darauf angebotenen
                Interaktionsmöglichkeiten und dem Layout, umgesetzt in XHTML, CSS und XForms</para>
        </sect1>
        <sect1>
            <title>Protokoll zwischen Client und Server</title>
            <para>HTTP-Nachrichten mit URLs und XML-Daten</para>
        </sect1>
        <sect1>
            <title>Server-Komponente</title>
            <para>Folgende Technologien werden benutzt: XQuery, XSLT und XProc.</para>
            <sect2>
                <title> XProc </title>
            <para> An der Server-Seite werden die Kunden-Anfragen einen XProc-Prozess auslösen, bei
                    dem das angegebene Datum als Element im XML-Dokument
                    <![CDATA[aktuellesDatum.xml]]> gespeichert und mit Schema
                    <![CDATA[aktuellesDatum.xsd]]> validiert wird.</para>
            <para>Als nächstes, wird das XML-Dokument <![CDATA[sampleCalendarX.xml]]> durch
                    XQuery-XSLT-Pipe transformiert . Als Output erhalten wir entsprechenden
                    Browser-Sicht. XProc erlaubt es, Workflow zu automatisieren und
                    veranschaulichen.</para>
                <para>Bemerkung: In der eXist-Umgebung gibt es die Möglichkeit, diesen Prozess
                    mithilfe von Funktion transform:transform innerhalb von XQuery durchzuführen, wo
                    man ein Dokument, ein Stylesheet und die Transformationsparameter als Argumente
                    eingibt, und das Ergebnis bekommt. Wir haben uns dennoch letztendlich für XProc
                    entschieden, und zwar aus folgenden Gründen.</para>
                <para> Erstens, ist die Unterstützung von dieser Funktion in eXist noch nicht ganz
                    ausgereift, was Fehlermeldungen bedeutet.  (Dasselbe gilt übrigens auch für
                    XProc-Module in eXide). Darüber hinaus, wird bei der Benutzung von XProc die
                    Architektur (<emphasis role="italic">welche</emphasis> Operationen <emphasis
                        role="italic">wann</emphasis> passieren) von den eigentlichen Code für
                    diesen Operationen (<emphasis role="italic">wie</emphasis> sie ausgeführt
                    werden) getrennt: Separation of Concerns. Eine Integration von unterschiedlichen
                    Technologien (XQuery, XSLT, etc.) innerhalb von XProc ist auch nicht zu
                    unterschätzen.</para>
                <para>Um XProc durchführen zu können, mussten wir alle XQueries, die wir als Version
                    3.0 geschrieben haben, als Version 1.0 umzuschreiben. Saxon akzeptiert Version
                    3.0 nicht, auch wenn sie explizit erlaubt wurde. Es gibt auch angeblich keine
                    Pläne, 3.0 in der Zukunft als Default-Version zu setzen. Saxon im Calabash nehme
                    sie als nicht ausgereift genug dafür  an, so Oxygen-Webseite. Die Umstellung
                    lief ganz problemlos: Außer einer filter-Funktion, waren alle von uns
                    deklarierten Funktionen mit Version 1.0 völlig kompatibel.</para>
            <para>Der Pipe-Prozess läuft nach der Datumsvalidierung folgendermaßen ab. Als Input
                    kommt das Dokument <![CDATA[sampleCalendarX.xml]]> rein. Dann wird
                    Kunden-Anfrage getestet: ob Tages-, Wochen- oder Monats-Events gefragt wurde.
                    Dies erfolgt via <![CDATA[p:choose]]> step, wobei eine Verzweigung von drei
                    Optionen entsteht. Jede Option löst eine eigene Subpipe aus, wobei in jeder
                    Subpipe das XML-Dokument <![CDATA[sampleCalendarX.xml]]> als Input reingeht.
                    Wenn die Option "Tag" gewählt wurde,  erfolgt auf Input zunächst XQuery mit
                    <![CDATA[getforDate.xquery]]>. Dieser Step erzeugt als Output eine
                    XML-Zwischendatei dayEvents.xml, welche eine geordnete Sequenz von Events an
                    diesem Tag darstellt. Sie geht als Input in den XSLT-Transformation-Step. Dort
                    wird Kalendersicht im Browser mithilfe von <![CDATA[tagessicht.xsl]]> erzeugt.
                    Dabei wird als sekundäres Output eine Zwischendatei dayEvents.html gespeichert.
                    Für die Option "Monat" erfolgt XQuery mit <![CDATA[getforMonth.xquery]]> und
                    danach die Transformation mit <![CDATA[monatssicht.xsl]]>. Die "Woche"-Subpipe
                    funktioniert genau so mit<![CDATA[getforWeek.xquery]]> und
                    <![CDATA[wochensicht.xsl]]>
                </para>
            <para>Output für alle drei Subprozesse wird der in Browser angezeigte Kalendersicht.</para>
                <figure>
                    <title>EPK: XProc-Prozess</title>
                    <mediaobject>
                        <imageobject>
                             <imagedata fileref="Images/XProcProzess.png" scale="70"/> 
                        </imageobject>
                    </mediaobject>
                </figure>
    
                <para>Ein anderer Prozess wird bei der Events-Änderung ausgelöst. Die Änderung wird
                    durchgeführt und in Datenbank gespeichert,  am Ende wird
                    <![CDATA[sampleCalendarX.xml]]> mit dem Schema <![CDATA[CalendarX.xsd]]>
                    validiert.</para>
            </sect2>
        <sect2><title> XQuery </title>
            <para> Client hat die Möglichkeit, für ein von ihm auserwähltes Datum drei unterschiedliche Anfragen an DB zu stellen: 
            <itemizedlist>
                <listitem>
                    <para>Events für dieses Datum</para>
                </listitem>
                <listitem>
                    <para>Events für eine Woche, inklusive dieses Datum</para>
                </listitem>
                <listitem>
                    <para>Events für einen Kalendermonat, inklusive dieses Datum</para>
                </listitem>
            </itemizedlist></para>
                <para><emphasis role="underline">Module:</emphasis></para>
                <para>Um Durchblick und Wiederverwendung von den Hilfsfunktionen zu gewährleisten,
                    haben wir die Queries in die folgenden Module aufgeteilt: <itemizedlist>
                        <listitem>
                            <para><![CDATA[functX.xquery]]> - Module</para>
                            <para> Das ist eine Sammlung von den FunctX-funktionen, die andere
                                Hilfsfunktionen benutzen. Hauptsächlich sind diese Zeit-verbundenen
                                Funktionen, die in XSLT-Abschnitt bereits besprochen wurden. </para>
                        </listitem>
                        <listitem>
                            <para><![CDATA[isinPat.xquery]]> (Hilfsfunktionen)- Module</para>
                            <para>Eine Sammlung von den aneinanderabhängigen Funktionen.</para>
                        </listitem>
                    </itemizedlist></para>
            <para>
                    <table frame="all">
                        <title>Event XQueries Summary</title>
                        <tgroup cols="4">
                            <colspec colname="newCol1" colnum="1" colwidth="142px"/>
                            <colspec colname="c1" colnum="2" colwidth="160px"/>
                            <colspec colname="c2" colnum="3" colwidth="264px"/>
                            <colspec colname="c3" colnum="4" colwidth="297px"/>
                            <thead>
                                <row>
                                    <entry><emphasis role="italic">Events</emphasis></entry>
                                    <entry>Day Events</entry>
                                    <entry>Week Events</entry>
                                    <entry>Month Events</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry><emphasis role="italic">Main <![CDATA[.xquery]]>
                                            file</emphasis></entry>
                                    <entry><![CDATA[getforDate.xquery]]></entry>
                                    <entry><![CDATA[getforWeek.xquery]]></entry>
                                    <entry><![CDATA[getforMonth.xquery]]></entry>
                                </row>
                                <row>
                                    <entry><emphasis role="italic">additional modules
                                            used</emphasis></entry>
                                    <entry>
                                        <itemizedlist>
                                            <listitem>
                                                <para><![CDATA[isinPat.xquery]]></para>
                                            </listitem>
                                            <listitem>
                                                <para><![CDATA[functX.xquery]]></para>
                                            </listitem>
                                        </itemizedlist>
                                    </entry>
                                    <entry>
                                        <itemizedlist>
                                            <listitem>
                                                <para><![CDATA[isinPat.xquery]]></para>
                                            </listitem>
                                            <listitem>
                                                <para><![CDATA[functX.xquery]]></para>
                                            </listitem>
                                        </itemizedlist>
                                    </entry>
                                    <entry>
                                        <itemizedlist>
                                            <listitem>
                                                <para><![CDATA[isinPat.xquery]]></para>
                                            </listitem>
                                            <listitem>
                                                <para><![CDATA[functX.xquery]]></para>
                                            </listitem>
                                        </itemizedlist>
                                    </entry>
                                </row>
                                <row>
                                    <entry><emphasis role="italic">specific declared auxiliary
                                            functions</emphasis></entry>
                                    <entry> none</entry>
                                    <entry>
                                        <itemizedlist>
                                            <listitem>
                                                <para><![CDATA[w:getEventsForWeek($d, $i)]]></para>
                                            </listitem>
                                            <listitem>
                                                <para><![CDATA[w:getEvents ($d as xs:date?, ]]></para>
                                                <para>
                                                  <![CDATA[$i as xs:integer)]]>
                                                </para>
                                            </listitem>
                                        </itemizedlist>
                                    </entry>
                                    <entry>
                                        <itemizedlist>
                                            <listitem>
                                                <para><![CDATA[m:getEventsForMonth ($d, $i, $j)]]></para>
                                            </listitem>
                                            <listitem>
                                                <para><![CDATA[m:getEvents ($d as xs:date?, ]]></para>
                                                <para>
                                                  <![CDATA[$i as xs:date, $j as xs:date)]]></para>
                                            </listitem>
                                        </itemizedlist>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>      
         <para><emphasis role="bold">Modul<![CDATA[isinPat.xquery]]>und Queries für Tag, Woche und
                        Monat</emphasis></para>  
                <para>Die einzige Hilfsfunktion aus dem "isinPat"-Modul, die von den Day-, Week- und
                    Month-XQueries direkt benutzt wird, ist <emphasis role="italic">
                        <![CDATA[local:forDay ($d)]]>
                    </emphasis>Funktion. . </para>
                <para>Folgendes Diagramm zeigt den Zusammenspiel von unterschiedlichen Funktionen
                    innerhalb des "isinPat"-Moduls, sowie mit den externen Module und Queries. </para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata scalefit="1" width="70%" contentdepth="70%" fileref="Images/isinPat.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>XQuery für die Events an dem Tag heißt <emphasis role="italic"><emphasis
                            role="bold">"getforDate.xquery"</emphasis></emphasis>. XQuery <emphasis
                        role="italic">"getforDate"</emphasis> setzt als Argument das von dem Client
                    angegebene Datum und ruft die Funktion <![CDATA[local:forDay($d)]]> aus dem
                    "isinPat"-Modul. Diese erzeugt als Ergebnis eine XML-Datei, welche Root-Element
                    <![CDATA[<events>]]> mit einem Attribute "date" - das Datum, hat . Darin
                    enthalten sind <![CDATA[<event>]]>Elemente - alle Events, die an diesem Datum
                    stattfinden</para>
<para><programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<events date="2015-06-16">
   <event>
      <datum>2015-06-16</datum>
      <datumWochenTag>2</datumWochenTag>
      <datumJahresTag>167</datumJahresTag>
      <startZeit>12:15:00</startZeit>
      <startZeitInMin>735</startZeitInMin>
      <endZeit>13:45:00</endZeit>
      <endZeitInMin>825</endZeitInMin>
      <beschreibung>test 2nd event in day</beschreibung>
      <tagZuvor>2015-06-15</tagZuvor>
      <tagDanach>2015-06-17</tagDanach>
      <location>00.09.13A</location>
      <attendees>
         <attendee>Anne Brüggemann-Klein</attendee>
      </attendees>
   </event>
   <event>
 ...
   </event>
</events>]]>
<remark>Ergebnis von <![CDATA[getforDate.xquery]]></remark></programlisting></para>
<para> </para>
                <para>Die XQuery <emphasis role="italic"><emphasis role="bold"
                            >"getforWeek.xquery"</emphasis></emphasis> prüft, an welchem Tag der
                    Woche das gesuchte Datum stattfindet und ruft die
                    Hilfsfunktion<![CDATA[w:getEventsForWeek($d, $i)]]> auf, wo $i - Nummer des
                    Wochentages ist. Falls das Datum am Montag vorkommt, ruft die Funktion für
                    dieses Datum die Funktion <![CDATA[local:forDay($d)]]> aus dem "isinPat"-Modul.
                    Für den nächsten Tag, ruft sie die zweite Hilfsfunktion "w:getEvents". Falls das
                    Datum an einem anderen Wochentag vorkommt, ruft die Funktion sich selbst
                    rekursiv für den vorigen Tag auf, usw. bis sie zum Montag dieser Woche
                    kommt.</para>
                <para>Die Funktion <![CDATA[w:getEvents($d, $i)]]> ruft <![CDATA[local:forDay($d)]]>
                    aus dem "isinPat"-Modul auf und für den nächsten Tag ruft sie sich selbst auf.
                    Usw. bis sie zum Ende der Woche kommt. Somit entsteht eine Sequenz von den
                    Events für jeden Tag der Woche, die das gesuchte Datum enthält. Das ganze wird
                    unter &lt;events> Root-Element verpackt.</para>
                <para>Ähnlich verhält sich auch <emphasis role="italic"><emphasis role="bold"
                            >"getforMonth.xquery"</emphasis></emphasis>, mit Monatsevents als
                    Ergebnis.</para>
                <para><emphasis role="underline">Was passiert innerhalb von
                        "isinPat"-Modul</emphasis> eher das Ergebnis geliefert wird?</para>
                <para>Als Erstes, ruft die Funktion <emphasis role="italic"
                        >local:forDay($d)</emphasis> die Funktion<emphasis role="italic">
                        <![CDATA[local:getEventsForDay ($d as xs:date?)]]></emphasis>. Diese muss
                    eine Sequenz ohne Root-Element von allen an diesem Tag stattfindenden Events ,
                    als "eventRule" mit allen dazugehörigen Attribute und Unterelemente, liefern-
                    genauso, wie sie im sampleCalendarX.xml erscheinen.</para>
                <para>Um diese Sequenz zu bekommen, geht die Funktion<emphasis role="italic">
                        <![CDATA[local:getEventsForDay ($d as xs:date?)]]></emphasis> durch alle im
                    sampleCalendarX.xml gespeicherte Events (als "eventRule") und prüft deren
                    "recurrencePattern"-Unterelement mithilfe von Funktion <emphasis role="italic"
                        ><![CDATA[local:isDateInPattern ($d as xs:date, $p as xs:string?)]]></emphasis>
                    :</para>
                <para>Diese Funktion nimmt das Datum und den Patternnamen von "recurrencePattern"
                    als Argumente und liefert eine boolische Antwort, ob an diesem Datum dieses
                    Pattern stattfindet. </para>
                <para>Weil "recurrencePattern" ausschließlich einen Namen hat, ohne Verweise auf
                    Datum oder Pattern-type, muss die Funktion alle unter &lt;patterns> gespeicherte
                    Patterns durchgehen, bis sie den gesuchten Pattern findet und ihn dann bzgl. des
                    Datums prüft.</para>
                <para><programlisting><![CDATA[ declare function local:isDateInPattern ($d as xs:date, $p as xs:string?) as xs:boolean
 {
 ((local:isInDaily($d, $p)) or (local:isInWeekly($d,$p))  or (local:isInUnion($d,$p)) or (local:isInIntersection($d,$p))or (local:isInDifference($d,$p)))
 };]]></programlisting></para>
                <para>Es gibt 2 einfache und 3 komplexe Patterns, die in Frage kommen. Für jeden
                    Pattern gibt es eine entsprechende Funktion: "isinDaily", "isinWeekly",
                    "isinDifference", isinUnion" und "isinIntersection". </para>
                <para>Die simple Patterns sind "daily" und "weekly" Patterns. Bei jedem
                    "daily"-Pattern genügt es, Attribute "startDate" und "endDate" als Argumente der
                    <![CDATA[functx:between-inclusive ($d, $dp/@startDate ,$dp/@endDate)]]>
                    übergeben und prüfen, ob das Datum zwischen Anfang und Ende des Patterns liegt.
                    Bei dem "weekly" Pattern kommt die
                    <![CDATA[(functx:day-of-week-name-en ($d) eq $wp/@dayOfWeek)]]> Funktion im
                    Spiel, die prüft, an welchem Tag der Woche das gesuchte Datum vorkommt und ob
                    dieser Tag dem "dayofWeek"-Attribut des Patterns entspricht.</para>
                <para>"isinDifference", "isinUnion" und "isinIntersection" alle rufen die Funktion
                        <emphasis role="italic"><![CDATA[local:isDateInPattern ]]></emphasis> für
                    "firstPattern" und für jede "furtherPattern" rekursiv auf. Die Ergebnisse
                    liefern true(), wenn:</para>
<simplelist>
<member> "isinDifference": das Datum befindet sich im "firstPattern" und in keinem der
                        "furtherPatterns".</member>
<member> "isinUnion": das Datum befindet sich im "firstPattern" oder in einem der
                        "furtherPatterns".</member>
                    <member>"isinIntersection":das Datum befindet sich im "firstPattern" und in
                        jedem der "furtherPatterns".</member>   
</simplelist>


                <para>Die Gedanke hinter der Aufbau der Funktion <emphasis role="italic"
                        ><![CDATA[local:isDateInPattern ]]></emphasis> war, dass weil XQuery eine
                    funktionelle Sprache ist, wird die Funktion alle Pattern-Types nacheinander
                    durchgehen ( als erstes alle daily, dann alle weekly Patterns, etc.), und,
                    sobald der gesuchte Pattern zutrifft, Ergebnis liefern, ohne alle
                    &lt;pattern>-Elemente durchgehen zu müssen. Das spart bei der Suche die Zeit und
                    lässt auch den rekursiven Aufrufe die Antwort schneller zu bekommen.</para>
                <para> </para>

          </sect2>
        </sect1>
    </chapter>
    <chapter>
        <title>Reflexion</title>
        <sect1>
            <title>Organisation der Arbeit im Team</title>
            <para>Da unser Team nur aus drei Personen besteht, war die Kommunikation im Team relativ
                einfach. Neben mehreren Treffen, erfolgte ein regelmäßiger Austausch per E-Mail und
                per Telefon. Für die Entwicklung und Dokumentation des Projektes verwendeten wir das
                Versionverwaltungssystem GitHub. Jedes Gruppenmitglied dokumentierte die Arbeit
                direkt in der DocBook-Datei, sodass die übrigen Teilnehmer nochmal detaililert
                nachlesen konnten, was genau gemacht wurde. Zudem wurde jedem Commit eine kurze
                Beschreibung beigefügt.</para>
            <para>Bei den Gruppen-Treffen stellte dann jedes Mitglied die von ihr entwickelten
                Programmteile vor und das Team diskutierte eventuell aufgetretene Probleme. Danach
                wurden die Schritte bis zum nächsten Treffen besprochen, in einer ToDo-Liste
                festgehalten und als einzelne Aufgaben unter den Gruppenmitlgiedern aufgeteilt.
                Jedes Gruppenmitglied hatte somit selbst die Möglichkeit mitzubestimmen, in welchen
                Bereich sie sich bis zum nächsten Termin näher einarbeiten wollte.</para>
            <para>Zusammenfassend bleibt festzuhalten, dass die Arbeit im Team sehr gut verlief. Gab
                es kleinere Probleme, so wurde auch mal schnell das Telefon in die Hand genommen
                oder eine E-Mail geschrieben, um ein anderes Gruppenmitglied nach einer schnellen
                Lösung zu fragen. Die Kommunikation funktionierte reibungslos und so konnten wir
                fast immer alles, was wir uns zwischen zwei Treffen vorgenommen hatten, umgesetzen.
                Alle Gruppenmitglieder waren motiviert und arbeiteten nahezu in gleichem Umfang am
                Projekt. </para>
        </sect1>
        <sect1>
            <title>Thematik CalendarX</title>
            <para/>
        </sect1>
        <sect1>
            <title>Organisation und Betreuung im Praktikum</title>
            <para>Text</para>
        </sect1>
    </chapter>
</book>
